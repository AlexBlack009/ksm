package ksm

import (
	"crypto/rand"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"reflect"

	"github.com/easonlin404/ksm/aes"
	"github.com/easonlin404/ksm/d"
	"github.com/easonlin404/ksm/rsa"
)

type SPCContainer struct {
	Version           uint32
	Reserved          []byte
	AesKeyIV          []byte
	EncryptedAesKey   []byte
	CertificateHash   []byte
	SPCPlayload       []byte
	SPCPlayloadLength uint32

	TTLVS map[uint64]TLLVBlock
}

type CKCContaniner struct {
	CKCVersion       uint32 //0x00000001
	Reserved         []byte
	CKCDataInitV     []byte //A random 16-byte initialization vector, generated by the KSM
	CKCPayload       []byte //A variable-length set of contiguous TLLV blocks
	CKCPayloadLength uint32 //The number of bytes in the encrypted CKC payload.
}

// This function will compute the content key context returned to client by the SKDServer library.
//       incoming server playback context (SPC message)
func GenCKC(playback []byte) error {
	pem := []byte{}           //TODO: server pk
	rck := RandomContentKey{} //TODO: pass frm parameter

	spcv1, err := ParseSPCV1(playback, pem)
	if err != nil {
		return err
	}

	ttlvs := spcv1.TTLVS
	skr1 := parseSKR1(ttlvs[Tag_SessionKey_R1])

	appleD := d.AppleD{} //TODO: pass from parameter
	//cp_d := d.CP_D_Function{}
	ask := []byte{} //TODO:

	r2 := ttlvs[Tag_R2]
	dask, err := appleD.Compute(r2.Value, ask)

	if err != nil {
		return err
	}

	DecryptedSKR1Payload, err := decryptSKR1Payload(*skr1, dask)
	if err != nil {
		return err
	}
	fmt.Printf("DASk Value:\n\t%s\n\n", hex.EncodeToString(dask))

	//Check the integrity of this SPC message
	checkTheIntegrity := ttlvs[Tag_SessionKey_R1_integrity].Value
	if !reflect.DeepEqual(checkTheIntegrity, DecryptedSKR1Payload.IntegrityBytes) {
		return errors.New(" Check the integrity of the SPC failed.")
	}

	fmt.Printf("DASk Value:\n\t%s\n\n", hex.EncodeToString(dask))
	fmt.Printf("SPC SK Value:\n\t%s\n\n", hex.EncodeToString(DecryptedSKR1Payload.SK))
	fmt.Printf("SPC [SK..R1] IV Value:\n\t%s\n\n", hex.EncodeToString(skr1.IV))
	//fmt.Printf("SPC R1 Value:\n%s\n\n",hex.EncodeToString(DecryptedSKR1Payload.R1))

	assetTTlv := ttlvs[Tag_AssetID]

	// assetId its length can range from 2 to 200 bytes

	if assetTTlv.ValueLength < 2 || assetTTlv.ValueLength > 200 {
		return errors.New("assetId its length must be range from 2 to 200 bytes")
	}

	enCk, err := encryptCK(assetTTlv.Value, rck, DecryptedSKR1Payload.SK)
	if err != nil {
		return err
	}

	returnTllvs := findReturnRequestBlocks(spcv1)

	ckcDataIv := generateRandomIv()
	ckcR1 := CkcR1{
		R1: DecryptedSKR1Payload.R1,
	}

	genCkcPayload(ckcDataIv, enCk, ckcR1, returnTllvs)
	return nil
}

func genCkcPayload(iv CkcDataIv, enCk []byte, ckcR1 CkcR1, returnTllvs []TLLVBlock) ([]byte, error) {
	//TODO: The order of these blocks should be random.
	var ckcPayload []byte

	//Content Key TLLV
	var contentKeyTllv []byte
	contentKeyTllv = append(contentKeyTllv, []byte{0x58, 0xb3, 0x81, 0x65, 0xaf, 0x0e, 0x3d, 0x5a}...) //TODO: using Tag_Encrypted_CK?
	contentKeyTllv = append(contentKeyTllv, []byte{0x00, 0x00, 0x00, 0x30}...)                         // Block length: Value(32) + Padding(16)
	contentKeyTllv = append(contentKeyTllv, []byte{0x00, 0x00, 0x00, 0x20}...)                         // Value length: IV(16) + CK(16)
	contentKeyTllv = append(contentKeyTllv, iv.IV...)
	contentKeyTllv = append(contentKeyTllv, enCk...)

	padding := make([]byte, 16)
	rand.Read(padding)
	contentKeyTllv = append(contentKeyTllv, padding...)

	if len(ckcPayload) != 64 {
		return nil, errors.New("ckcPayload len must be 64.")
	}

	ckcPayload = append(ckcPayload, contentKeyTllv...)

	//R1Tllv
	var r1Tllv []byte
	r1Tllv = append(r1Tllv, []byte{0xea, 0x74, 0xc4, 0x64, 0x5d, 0x5e, 0xfe, 0xe9}...)

	paddingSize := 32 - len(ckcR1.R1)%16
	totalBlockLength := len(ckcR1.R1) + paddingSize

	BlockLength := make([]byte, 4)
	binary.BigEndian.PutUint32(BlockLength, uint32(totalBlockLength))
	r1Tllv = append(r1Tllv, BlockLength...)

	ValueLength := make([]byte, 4)
	binary.BigEndian.PutUint32(ValueLength, uint32(len(ckcR1.R1)))
	r1Tllv = append(r1Tllv, ValueLength...)
	r1Tllv = append(r1Tllv, ckcR1.R1...) // 44-byte R1 value

	padding2 := make([]byte, paddingSize)
	rand.Read(padding2)
	r1Tllv = append(r1Tllv, padding...)

	ckcPayload = append(ckcPayload, r1Tllv...)

	return ckcPayload, nil

}

func generateRandomIv() CkcDataIv {
	key := make([]byte, 16)
	rand.Read(key)

	return CkcDataIv{
		IV: key,
	}

}

func encryptCkcPayload(ckcPayload []byte) CkcEncryptedPayload {
	return CkcEncryptedPayload{}
}

func findReturnRequestBlocks(spcv1 *SPCContainer) []TLLVBlock {
	tagReturnReq := spcv1.TTLVS[Tag_ReturnRequest]

	var returnTllvs []TLLVBlock

	for currentOffset := 0; currentOffset < len(tagReturnReq.Value); {

		if ttlv, ok := spcv1.TTLVS[Tag_ReturnRequest]; ok {
			returnTllvs = append(returnTllvs, ttlv)
		} else {
			panic("Can not found  tag")
		}

		currentOffset += Field_Tag_Length
	}

	return returnTllvs
}

func encryptCK(assetId []byte, ck ContentKey, sk []byte) ([]byte, error) {
	contentKey, err := ck.FetchContentKey(assetId)
	if err != nil {
		return nil, err
	}

	var iv []byte
	iv = make([]byte, len(contentKey), len(contentKey))

	return aes.Encrypt(sk, iv, contentKey)
}

func ParseSPCV1(playback []byte, pem []byte) (*SPCContainer, error) {
	spcContainer := ParseSPCContainer(playback)

	spck, err := decryptSPCK(pem, spcContainer.EncryptedAesKey)
	if err != nil {
		return nil, err
	}

	spcPayloadRow, err := decryptSPCpayload(spcContainer, spck)
	if err != nil {
		return nil, err
	}

	printDebugSPC(spcContainer)

	spcContainer.TTLVS = parseTLLVs(spcPayloadRow)

	return spcContainer, nil
}

func ParseSPCContainer(playback []byte) *SPCContainer {
	spcContainer := &SPCContainer{}
	spcContainer.Version = binary.BigEndian.Uint32(playback[0:4])
	spcContainer.Reserved = playback[4:8]
	spcContainer.AesKeyIV = playback[8:24]
	spcContainer.EncryptedAesKey = playback[24:152]
	spcContainer.CertificateHash = playback[152:172]
	spcContainer.SPCPlayloadLength = binary.BigEndian.Uint32(playback[172:176])
	spcContainer.SPCPlayload = playback[176 : 176+spcContainer.SPCPlayloadLength]

	return spcContainer
}

func FillCKCContainer() {
	//cocContainer:=
}

func parseTLLVs(spcpayload []byte) map[uint64]TLLVBlock {
	var m map[uint64]TLLVBlock
	m = make(map[uint64]TLLVBlock)

	for currentOffset := 0; currentOffset < len(spcpayload); {

		tag := binary.BigEndian.Uint64(spcpayload[currentOffset : currentOffset+Field_Tag_Length])
		currentOffset += Field_Tag_Length

		blockLength := binary.BigEndian.Uint32(spcpayload[currentOffset : currentOffset+Field_Block_Length])
		currentOffset += Field_Block_Length

		valueLength := binary.BigEndian.Uint32(spcpayload[currentOffset : currentOffset+Field_Value_Length])
		currentOffset += Field_Value_Length

		//paddingSize := blockLength - valueLength

		value := spcpayload[currentOffset : currentOffset+int(valueLength)]

		var skip bool
		switch tag {
		case Tag_SessionKey_R1:
			fmt.Printf("Tag_SessionKey_R1 -- %x\n", tag)
		case Tag_SessionKey_R1_integrity:
			fmt.Printf("Tag_SessionKey_R1_integrity -- %x\n", tag)
		case Tag_AntiReplaySeed:
			fmt.Printf("Tag_AntiReplaySeed -- %x\n", tag)
		case Tag_R2:
			fmt.Printf("Tag_R2 -- %x\n", tag)
		case Tag_ReturnRequest:
			fmt.Printf("Tag_ReturnRequest -- %x\n", tag)
		case Tag_AssetID:
			fmt.Printf("Tag_AssetID -- %x\n", tag)
		case Tag_TransactionID:
			fmt.Printf("Tag_TransactionID -- %x\n", tag)
		case Tag_ProtocolVersionsSupported:
			fmt.Printf("Tag_ProtocolVersionsSupported -- %x\n", tag)
		case Tag_ProtocolVersionUsed:
			fmt.Printf("Tag_ProtocolVersionUsed -- %x\n", tag)
		case Tag_treamingIndicator:
			fmt.Printf("Tag_treamingIndicator -- %x\n", tag)
		case Tag_kSKDServerClientReferenceTime:
			fmt.Printf("Tag_kSKDServerClientReferenceTime -- %x\n", tag)
		default:
			skip = true
		}

		if skip == false {
			fmt.Printf("Tag size:0x%x\n", valueLength)
			fmt.Printf("Tag length:0x%x\n", blockLength)
			fmt.Printf("Tag value:%s\n\n", hex.EncodeToString(value))

			tllvBlock := TLLVBlock{
				Tag:         tag,
				BlockLength: blockLength,
				ValueLength: valueLength,
				Value:       value,
			}

			m[tag] = tllvBlock

		}

		//TODO: paring ttlv
		currentOffset = currentOffset + int(blockLength)
	}

	return m
}

func parseSKR1(tllv TLLVBlock) *SKR1TLLVBlock {
	return &SKR1TLLVBlock{
		TLLVBlock: tllv,
		IV:        tllv.Value[0:16],
		Payload:   tllv.Value[16:112],
	}
}

func decryptSKR1Payload(skr1 SKR1TLLVBlock, dask []byte) (*DecryptedSKR1Payload, error) {
	if skr1.Tag != Tag_SessionKey_R1 {
		return nil, errors.New("decryptSKR1 doesn't match Tag_SessionKey_R1 tag.")
	}

	decryptPayloadRow, err := aes.Decrypt(dask, skr1.IV, skr1.Payload)
	if err != nil {
		return nil, err
	}

	if len(decryptPayloadRow) != 96 {
		return nil, errors.New("Wrong decrypt payload size. Must be 96 bytes expected.")
	}

	d := &DecryptedSKR1Payload{
		SK:             decryptPayloadRow[0:16],
		HU:             decryptPayloadRow[16:36],
		R1:             decryptPayloadRow[36:80],
		IntegrityBytes: decryptPayloadRow[80:96],
	}

	return d, nil
}

func printDebugSPC(spcContainer *SPCContainer) {
	fmt.Println("========================= Begin SPC Data ===============================")
	fmt.Printf("SPC container size %+v\n", spcContainer.SPCPlayloadLength)

	fmt.Println("SPC Encryption Key -")
	fmt.Println(hex.EncodeToString(spcContainer.EncryptedAesKey))
	fmt.Println("SPC Encryption IV -")
	fmt.Println(hex.EncodeToString(spcContainer.AesKeyIV))
	fmt.Println("================ SPC TLLV List ================")

}

// SPCK = RSA_OAEP d([SPCK])Prv where
// [SPCK] represents the value of SPC message bytes 24-151. Prv represents the server's private key.
func decryptSPCK(pkPem, enSpck []byte) ([]byte, error) {
	if len(enSpck) != 128 {
		return nil, errors.New("Wrong [SPCK] length, must be 128")
	}
	return rsa.OAEPPDecrypt(pkPem, enSpck)
}

// SPC payload = AES_CBCIV d([SPC data])SPCK where
// [SPC data] represents the remaining SPC message bytes beginning at byte 176 (175 + the value of
// SPC message bytes 172-175).
// IV represents the value of SPC message bytes 8-23.
func decryptSPCpayload(spcContainer *SPCContainer, spck []byte) ([]byte, error) {
	spcPayload, err := aes.Decrypt(spck, spcContainer.AesKeyIV, spcContainer.SPCPlayload)
	return spcPayload, err
}
